diff --git a/web/analysis/views.py b/web/analysis/views.py
index 6ad444c..5ad0a69 100755
--- a/web/analysis/views.py
+++ b/web/analysis/views.py
@@ -1,18 +1,15 @@
-# Copyright (C) 2010-2015 Cuckoo Foundation.
+# Copyright (C) 2010-2014 Cuckoo Foundation.
 # This file is part of Cuckoo Sandbox - http://www.cuckoosandbox.org
 # See the file 'docs/LICENSE' for copying permission.
 
 import sys
 import re
-import os
-import json
 
 from django.conf import settings
 from django.template import RequestContext
 from django.http import HttpResponse
 from django.shortcuts import render_to_response
 from django.views.decorators.http import require_safe
-from django.views.decorators.csrf import csrf_exempt
 
 import pymongo
 from bson.objectid import ObjectId
@@ -22,10 +19,8 @@ from gridfs import GridFS
 sys.path.append(settings.CUCKOO_PATH)
 
 from lib.cuckoo.core.database import Database, TASK_PENDING
-from lib.cuckoo.common.constants import CUCKOO_ROOT
-import modules.processing.network as network
 
-results_db = pymongo.MongoClient(settings.MONGO_HOST, settings.MONGO_PORT)[settings.MONGO_DB]
+results_db = pymongo.connection.Connection(settings.MONGO_HOST, settings.MONGO_PORT).cuckoo
 fs = GridFS(results_db)
 
 @require_safe
@@ -41,10 +36,7 @@ def index(request):
         for task in tasks_files:
             new = task.to_dict()
             new["sample"] = db.view_sample(new["sample_id"]).to_dict()
-
-            filename = os.path.basename(new["target"])
-            new.update({"filename": filename})
-
+            new["target"] = results_db.analysis.find_one({"info.id": int(new["id"])}, sort=[("_id", pymongo.DESCENDING)])
             if db.view_errors(task.id):
                 new["errors"] = True
 
@@ -114,8 +106,8 @@ def chunk(request, task_id, pid, pagenum):
                                   context_instance=RequestContext(request))
     else:
         raise PermissionDenied
-
-
+        
+        
 @require_safe
 def filtered_chunk(request, task_id, pid, category):
     """Filters calls for call category.
@@ -158,47 +150,6 @@ def filtered_chunk(request, task_id, pid, category):
     else:
         raise PermissionDenied
 
-@csrf_exempt
-def search_behavior(request, task_id):
-    if request.method == 'POST':
-        query = request.POST.get('search')
-        results = []
-
-        # Fetch anaylsis report
-        record = results_db.analysis.find_one(
-            {"info.id": int(task_id)}
-        )
-
-        # Loop through every process
-        for process in record["behavior"]["processes"]:
-            process_results = []
-
-            chunks = results_db.calls.find({
-                "_id": { "$in": process["calls"] }
-            })
-            for chunk in chunks:
-                for call in chunk["calls"]:
-                    query = re.compile(query)
-                    if query.search(call['api']):
-                        process_results.append(call)
-                    else:
-                        for argument in call['arguments']:
-                            if query.search(argument['name']) or query.search(argument['value']):
-                                process_results.append(call)
-                                break
-
-            if len(process_results) > 0:
-                results.append({
-                    'process': process,
-                    'signs': process_results
-                })
-
-        return render_to_response("analysis/behavior/_search_results.html",
-                                  {"results": results},
-                                  context_instance=RequestContext(request))
-    else:
-        raise PermissionDenied
-
 @require_safe
 def report(request, task_id):
     report = results_db.analysis.find_one({"info.id": int(task_id)}, sort=[("_id", pymongo.DESCENDING)])
@@ -208,34 +159,25 @@ def report(request, task_id):
                                   {"error": "The specified analysis does not exist"},
                                   context_instance=RequestContext(request))
 
-    # Creating dns information dicts by domain and ip.
-    if "network" in report and "domains" in report["network"]:
-        domainlookups = dict((i["domain"], i["ip"]) for i in report["network"]["domains"])
-        iplookups = dict((i["ip"], i["domain"]) for i in report["network"]["domains"])
-        for i in report["network"]["dns"]:
-            for a in i["answers"]:
-                iplookups[a["data"]] = i["request"]
-    else:
-        domainlookups = dict()
-        iplookups = dict()
-
     return render_to_response("analysis/report.html",
-                              {"analysis": report, "domainlookups": domainlookups, "iplookups": iplookups},
+                              {"analysis": report},
                               context_instance=RequestContext(request))
 
 @require_safe
 def file(request, category, object_id):
-    file_item = fs.get(ObjectId(object_id))
+    file_object = results_db.fs.files.find_one({"_id": ObjectId(object_id)})
 
-    if file_item:
-        # Composing file name in format sha256_originalfilename.
-        file_name = file_item.sha256 + "_" + file_item.filename
+    if file_object:
+        content_type = file_object.get("contentType", "application/octet-stream")
+        file_item = fs.get(ObjectId(file_object["_id"]))
 
-        # Managing gridfs error if field contentType is missing.
-        try:
-            content_type = file_item.contentType
-        except AttributeError:
-            content_type = "application/octet-stream"
+        file_name = file_item.sha256
+        if category == "pcap":
+            file_name += ".pcap"
+        elif category == "screenshot":
+            file_name += ".jpg"
+        else:
+            file_name += ".bin"
 
         response = HttpResponse(file_item.read(), content_type=content_type)
         response["Content-Disposition"] = "attachment; filename={0}".format(file_name)
@@ -246,22 +188,6 @@ def file(request, category, object_id):
                                   {"error": "File not found"},
                                   context_instance=RequestContext(request))
 
-
-@require_safe
-def full_memory_dump_file(request, analysis_number):
-    file_path = os.path.join(CUCKOO_ROOT, "storage", "analyses", str(analysis_number), "memory.dmp")
-    if os.path.exists(file_path):
-        content_type = "application/octet-stream"
-        response = HttpResponse(open(file_path, "rb").read(), content_type=content_type)
-        response["Content-Disposition"] = "attachment; filename=memory.dmp"
-
-        return response
-    else:
-        return render_to_response("error.html",
-                                  {"error": "File not found"},
-                                  context_instance=RequestContext(request))
-
-
 def search(request):
     if "search" in request.POST:
         error = None
@@ -288,8 +214,6 @@ def search(request):
                 records = results_db.analysis.find({"target.file.name": {"$regex": value, "$options": "-i"}}).sort([["_id", -1]])
             elif term == "type":
                 records = results_db.analysis.find({"target.file.type": {"$regex": value, "$options": "-i"}}).sort([["_id", -1]])
-            elif term == "string":
-                records = results_db.analysis.find({"strings" : {"$regex" : value, "$options" : "-1"}}).sort([["_id", -1]])
             elif term == "ssdeep":
                 records = results_db.analysis.find({"target.file.ssdeep": {"$regex": value, "$options": "-i"}}).sort([["_id", -1]])
             elif term == "crc32":
@@ -317,8 +241,6 @@ def search(request):
                                            "error": "Invalid search term: %s" % term},
                                           context_instance=RequestContext(request))
         else:
-            value = value.lower()
-
             if re.match(r"^([a-fA-F\d]{32})$", value):
                 records = results_db.analysis.find({"target.file.md5": value}).sort([["_id", -1]])
             elif re.match(r"^([a-fA-F\d]{40})$", value):
@@ -365,90 +287,3 @@ def search(request):
                                    "term": None,
                                    "error": None},
                                   context_instance=RequestContext(request))
-
-@require_safe
-def remove(request, task_id):
-    """Remove an analysis.
-    @todo: remove folder from storage.
-    """
-    anals = results_db.analysis.find({"info.id": int(task_id)})
-    # Only one analysis found, proceed.
-    if anals.count() == 1:
-        # Delete dups too.
-        for analysis in anals:
-            # Delete sample if not used.
-            if results_db.analysis.find({"target.file_id": ObjectId(analysis["target"]["file_id"])}).count() == 1:
-                fs.delete(ObjectId(analysis["target"]["file_id"]))
-            # Delete screenshots.
-            for shot in analysis["shots"]:
-                if results_db.analysis.find({"shots": ObjectId(shot)}).count() == 1:
-                    fs.delete(ObjectId(shot))
-            # Delete network pcap.
-            if "pcap_id" in analysis["network"] and results_db.analysis.find({"network.pcap_id": ObjectId(analysis["network"]["pcap_id"])}).count() == 1:
-                fs.delete(ObjectId(analysis["network"]["pcap_id"]))
-            # Delete dropped.
-            for drop in analysis["dropped"]:
-                if "object_id" in drop and results_db.analysis.find({"dropped.object_id": ObjectId(drop["object_id"])}).count() == 1:
-                    fs.delete(ObjectId(drop["object_id"]))
-            # Delete calls.
-            for process in analysis["behavior"]["processes"]:
-                for call in process["calls"]:
-                    results_db.calls.remove({"_id": ObjectId(call)})
-            # Delete analysis data.
-            results_db.analysis.remove({"_id": ObjectId(analysis["_id"])})
-    elif anals.count() == 0:
-        return render_to_response("error.html",
-                                  {"error": "The specified analysis does not exist"},
-                                  context_instance=RequestContext(request))
-    # More analysis found with the same ID, like if process.py was run manually.
-    else:
-        return render_to_response("error.html",
-                                  {"error": "The specified analysis is duplicated in mongo, please check manually"},
-                                  context_instance=RequestContext(request))
-
-    # Delete from SQL db.
-    db = Database()
-    db.delete_task(task_id)
-
-    return render_to_response("success.html",
-                              {"message": "Task deleted, thanks for all the fish."},
-                              context_instance=RequestContext(request))
-
-@require_safe
-def pcapstream(request, task_id, conntuple):
-    src, sport, dst, dport, proto = conntuple.split(",")
-    sport, dport = int(sport), int(dport)
-
-    conndata = results_db.analysis.find_one({ "info.id": int(task_id) },
-        { "network.tcp": 1, "network.udp": 1, "network.sorted_pcap_id": 1 },
-        sort=[("_id", pymongo.DESCENDING)])
-
-    if not conndata:
-        return render_to_response("standalone_error.html",
-            {"error": "The specified analysis does not exist"},
-            context_instance=RequestContext(request))
-
-    try:
-        if proto == "udp": connlist = conndata["network"]["udp"]
-        else: connlist = conndata["network"]["tcp"]
-
-        conns = filter(lambda i: (i["sport"],i["dport"],i["src"],i["dst"]) == (sport,dport,src,dst),
-            connlist)
-        stream = conns[0]
-        offset = stream["offset"]
-    except:
-        return render_to_response("standalone_error.html",
-            {"error": "Could not find the requested stream"},
-            context_instance=RequestContext(request))
-
-    try:
-        fobj = fs.get(conndata["network"]["sorted_pcap_id"])
-        # gridfs gridout has no fileno(), which is needed by dpkt pcap reader for NOTHING
-        setattr(fobj, "fileno", lambda: -1)
-    except:
-        return render_to_response("standalone_error.html",
-            {"error": "The required sorted PCAP does not exist"},
-            context_instance=RequestContext(request))
-
-    packets = list(network.packets_for_stream(fobj, offset))
-    return HttpResponse(json.dumps(packets), content_type="application/json")
diff --git a/web/templates/analysis/index.html b/web/templates/analysis/index.html
index 9501a94..1a8c45a 100644
--- a/web/templates/analysis/index.html
+++ b/web/templates/analysis/index.html
@@ -17,16 +17,23 @@
             <table class="table table-striped" style="table-layout: fixed;">
                 <thead>
                 <tr>
+                    <th>id</th>
                     <th>Timestamp</th>
-                    <th>Filename</th>
+                    <th>File name</th>
+                    <th>File type</th>
+                    <th>Windows</th>
                     <th>MD5</th>
                     <th>Status</th>
+
                 </tr>
                 </thead>
                 <tbody>
                 {% for analysis in files %}
                     <tr>
                         <td>
+                            {{analysis.target.info.id}}
+                        </td>
+                        <td>
                         {% if analysis.status == "reported" %}
                             {{analysis.completed_on}}
                         {% else %}
@@ -34,7 +41,13 @@
                         {% endif %}
                         </td>
                         <td>
-                            {{analysis.filename}}
+                            {{analysis.target.target.file.name}}
+                        </td>
+                        <td>
+                            {{analysis.target.target.file.type}}
+                        </td>
+                        <td>
+                            {{analysis.target.info.machine.name}}
                         </td>
                         <td style="word-wrap: break-word;">
                             {% if analysis.status == "reported" %}
